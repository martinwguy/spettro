spettro - Show a moving log-frequency axis spectrograms of music while it plays

Following on from the work at http://wikidelia.net/wiki/Spectrograms
here is a program to show a window onto the spectrogram with a
vertical green one-pixel-wide line half way across the window to
show the current playing position.

There is an screencast of it at https://youtu.be/fGRsLX0Ec1E

User interface
--------------
For the touch-screen version, we want pinch to zoom, drag to pan with
buttons for FFT size etc.
For the mouse version, click and drag (also arrow keys) pans the time
and the frequency axes with buttons to zoom the time axis, frequency axis,
FFT size and brightness/contrast (a.k.a. maximum value and dynamic range).

Tap or click the screen or hit space to start/pause/resume/restart playback.

Panning left and right skips the song to the new position.
Panning up and down moves the view on the frequency axis.

A time grid would be nice too, with a button to turn it on/off and, when on,
with a setting for the number of beats per bar giving more a luminous line
every N "beats". Users can drag a bar line to align it to a feature.
The first time they do this, the position (phase) of the time scale shifts.
When you drag a different bar line, the one you just dropped stays where it is
and the time scale stretches. Move a different bar line and, again,
the last one you clicked stays still and the time scale stretches.

FFT sizes are powers of 2 by default; that way we can use some super-fast
alternative FFT routines. If you have a keyboard, you should be able to
set the FFT size (or FFT frequency) in a box. Alternatively, a slider that
clicks to the next power of 2 if you click its <| |> endcaps or you can
move the slider smoothly to choose an intermediate size.

How to allocate finite computing resources
------------------------------------------
If we're playing the song, the first priority in screen update should be the
leading edge of the display: what will play in a few seconds' time. That way,
whatever happens, if they keep playing we will eventually get the display right.
We launch an FFT for the audio that is entering the display at the right edge.
When the result of the calculaction returns, we paint a column wide as many
pixels as the time that the calculation took and launch a new FFT for the
current audio at the leading edge of the scrolling display.

If they stop, and the screen is not fully repainted, it repaints the missing
parts of the display from right to left at the same speed as when playing
in realtime. This way, when they stop and it continues updating the screen,
the size of the pixel columns will be even across the display.
This suggests keeping a list of the time periods that are not updated on the
display and working oldest-to-newest in that.
When they stop, we don't continue calculating to fill in detail, alla JPEG,
for love of the battery.

When we start up, mark the whole of the displayed region as "to be updated"
so it starts updating from right to left at playing speed, stopping when it
gets to the centre of the screen. They hit play and it calculates the right
edge of the window, scrolling the display and writing a column of several
pixels.

If they pan, again it updates from right to left at playing speed.

An alternative strategy could be, while playing, to scroll the display
one pixel at a time, following the music, and replicating the rightmost
edge column of pixels then, when calculation results arrive, repaint the
rightmost column with the new results (or the rightmost columns if we want
to allow for the time taken to compute the FFT. If we know how long each
FFT will take, we could calculate the FFT of a fraction of a second in advance,
to mitigate the visiblity of the right-edge-repainting.


Program structure
-----------------
- A calc thread doing one FFT each receiving requests for an FFT around a
  particular moment and returning the result of same.
  Allow multiple threads to exploit multiple processors?
- A GUI thread doing UI handling, scrolling of the display, starting/stopping
  music etc.

GUI->calc: "Send me the FFT for this time region"
calc->GUI: "Here's the result for audio around time T"

When calc delivers a result, it then starts calculating at a new point in the
outstanding region, if any, according to the real time elapsed since T.
This means the results won't necessarily be evenly-spaced in time.
How do you map from a pixmap with unevenly-spaced columns to a fixed-pitch
display? Cosine mapping between pairs of points?

Add to that the reverse mapping to apply the logarithmic frequency axis and
the color map and hey presto.

    Martin Guy <martinwguy@gmail.com>, December 2016 - January 2017.
